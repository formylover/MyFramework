package project.jun.dao;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.StringTokenizer;import javax.naming.NamingException;import javax.sql.DataSource;import net.sf.ehcache.Cache;import org.apache.ibatis.session.SqlSession;import org.apache.log4j.Logger;import org.mybatis.spring.support.SqlSessionDaoSupport;import project.jun.dao.parameter.HoQueryParameterMap;import project.jun.dao.result.HoMap;import project.jun.dao.result.HoList;import project.jun.dao.sql.HoSqlBatchImpl;import project.jun.exception.HoException;import project.jun.util.HoUtil;import project.jun.was.servlet.HoServlet;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;/** * @author  sks */public class HoDaoSupport extends SqlSessionDaoSupport { // SqlMapClientDaoSupport	protected static Logger          logger     = Logger.getLogger(HoDaoSupport.class);	NamedParameterJdbcTemplate       jdbcTemplate = null;		// 배치 실행 ID	public final String BATCH_SQL_ID = "DAO_BATCH_SQL_ID";  // return String	// 배치 전체 대상 건수	public final String BATCH_TOTAL_COUNT = "DAO_TOTAL_COUNT."; // return Integer	// 배치 실행 건수	public final String BATCH_EXECUTE_COUNT = "DAO_EXECUTE_COUNT."; // return Integer	// 배치 성공 결과수 	public final String BATCH_SUCCESS_COUNT = "BATCH_SUCCESS_COUNT."; // return Integer	// 배치 실패 결과수 	public final String BATCH_FAILURE_COUNT = "DAO_FAILURE_COUNT."; // return Integer	private Map<String, String>    displayFormat = null;	private Cache                  cache;	private Map<String, String>    cacheMap               = null;	private DataSource             dataSource               = null;	private HoServlet              servlet                = null;		/**	 * @return	 */	public Cache getCache() {		return cache;	}	/**	 * @param cache	 */	public void setCache(Cache cache) {		this.cache = cache;	}	public HoServlet getHoServlet() {		return this.servlet;	}		public void setHoServlet(HoServlet servlet) {		this.servlet = servlet;	}		/*	protected SqlMapClient getSql() {		return getSqlMapClient();	}*//*	protected SqlMapClientTemplate getSqlTemplate() {		return getSqlMapClientTemplate();	}*/	/**	 * @param dataSource	 */	public void setDataSource(DataSource dataSource) {		this.dataSource = dataSource;	}	/**	 * @return	 */	public DataSource getDataSource() {		return dataSource;	}	protected SqlSession getSqlTemplate() {		//SqlSessionTemplate sessionTemplate = (SqlSessionTemplate) getSqlSession();		//return sessionTemplate.getSqlSessionFactory().openSession(ExecutorType.SIMPLE);		return getSqlSession();	}	protected SqlSession getSqlTemplateBatch() {		//SqlSessionTemplate sessionTemplate = (SqlSessionTemplate) getSqlSession();		//return sessionTemplate.getSqlSessionFactory().openSession(ExecutorType.BATCH);		return getSqlSession();	}	/*	 * 한건의 정보를 가져온다.	 * @see project.jun.dao.HoDao#queryForInfo(java.lang.String)	 */	protected HoMap queryForInfo(String sqlId)	{		return new HoMap(getSqlTemplate().selectOne(sqlId));	}	/*	 * 한건의 정보를 가져온다.	 * @see project.jun.dao.HoDao#queryForInfo(java.lang.String)	 */	protected HoMap queryForInfo(String sqlId, boolean checkOne) throws HoException	{		return new HoMap(getSqlTemplate().selectOne(sqlId), checkOne);	}	/*	 * 한건의 정보를 가져온다.	 * @see project.jun.dao.HoDao#queryForInfo(java.lang.String)	 */	protected HoMap queryForInfo(String sqlId, HoQueryParameterMap value)	{		return new HoMap(getSqlTemplate().selectOne(sqlId, value));	}	/*	 * 한건의 정보를 가져온다.	 * @see project.jun.dao.HoDao#queryForInfo(java.lang.String)	 */	protected HoMap queryForInfo(String sqlId, HoQueryParameterMap value, boolean checkOne) throws HoException	{		return new HoMap(getSqlTemplate().selectOne(sqlId, value), checkOne);	}	/**	 * 0건이상의 정보를 가져온다.	 */	protected HoList queryForList(String sqlId)	{		return new HoList(getSqlTemplate().selectList(sqlId));	}	/**	 * 0건이상의 정보를 가져온다.	 */	protected HoList queryForList(String sqlId, HoQueryParameterMap value)	{		return new HoList(getSqlTemplate().selectList(sqlId, value));	}	/**	 * CUD를 실행한다.	 * @param sql	 * @return	 * @throws HoException	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 * @throws SQLException	 * @throws NamingException	 */	protected int update(String sqlId)	{		return getSqlTemplate().update(sqlId);	}	/**	 * CUD를 실행한다.	 * @param sql	 * @return	 * @throws HoException	 * @throws SQLException	 * @throws NamingException	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected int update(String sqlId, HoQueryParameterMap value )	{		return getSqlTemplate().update(sqlId, value);	}	/**	 * CUD를 실행한다.	 * @param sql	 * @return	 * @throws HoException	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 * @throws SQLException	 * @throws NamingException	 */	protected int forceUpdate(String sqlId)	{		return getSqlTemplate().update(sqlId);	}	/**	 * CUD를 실행한다.	 * @param sql	 * @return	 * @throws HoException	 * @throws SQLException	 * @throws NamingException	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected int forceUpdate(String sqlId, HoQueryParameterMap value )	{		return getSqlTemplate().update(sqlId, value);	}	/**	 * PROCEDURE를 실행한다.	 */	protected HoMap call(String sqlId, HoQueryParameterMap value) {		return new HoMap( getSqlTemplate().selectOne(sqlId, value));	}	/**	 * BATCH를 실행한다.	 * @param sql	 * @param values	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected  List<HoDaoSqlResult>  batch(String sqlId, HoQueryParameterMap [] valueses)	{				int [] result = new int[valueses.length];		// 오류 발생 건..		List<HoDaoSqlResult>  sqlResult = new ArrayList<HoDaoSqlResult>();		String   userId = "";		String   ssnSqlIdx = "";		int successCnt = 0, failureCnt = 0;				if( getHoServlet() != null ) {			userId = getHoServlet().getHoSession().getString("USER_ID") ;		}				if( getHoServlet() != null ) {	    	// 배치 실행 SQL ID저장			getHoServlet().getHoSession().setObject(BATCH_SQL_ID + userId, sqlId);						ssnSqlIdx = userId + "_" + sqlId;						// 세션에 전체 대상건 저장			getHoServlet().getHoSession().setObject(BATCH_TOTAL_COUNT + ssnSqlIdx, new Integer(valueses.length));		}				for( int i=0 ; i<valueses.length ; i++) {			try {				result [i] = getSqlTemplateBatch().insert(sqlId, valueses[i]);				// 세션에 50건 단위로 실행 건 저장				if( getHoServlet() != null && i%50 == 0 ) {					getHoServlet().getHoSession().setObject(BATCH_EXECUTE_COUNT + ssnSqlIdx, new Integer(i));				}				successCnt++;				sqlResult.add(new HoDaoSqlResult(userId, sqlId, i, result[i] == 1 , result[i] == 1 ? null : new Exception("Error(-1).")));			} catch(Exception e) {				// e.printStackTrace();				result [i] = -1;				failureCnt++;				sqlResult.add(new HoDaoSqlResult(userId, sqlId, i, false, e));			}		}		if( getHoServlet() != null ) {			// 세션에 전체 실행 건 저장			getHoServlet().getHoSession().setObject(BATCH_EXECUTE_COUNT + ssnSqlIdx, new Integer(valueses.length));			// 배치 성공 처리 결과수..			getHoServlet().getHoSession().setObject(BATCH_SUCCESS_COUNT + ssnSqlIdx, new Integer(successCnt) );			// 배치 실패 처리 결과수..			getHoServlet().getHoSession().setObject(BATCH_FAILURE_COUNT + ssnSqlIdx, new Integer(failureCnt) );		}		return sqlResult;	}	/**	 * 쿼리를 실행하기 위한 datasource를 설정한다.	 * @return	 */	protected NamedParameterJdbcTemplate getSqlRaw() {		if( this.jdbcTemplate == null ){			this.jdbcTemplate = new NamedParameterJdbcTemplate(this.getDataSource());		}		return this.jdbcTemplate;	}	/**	 *  SQL을 직접 실행하여 1건의 정보를 가져온다.	 * @param sql	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected HoMap queryForInfoSql(String sql, HoQueryParameterMap value)	{		logger.info(sql);		logger.info(value);		return new HoMap(getSqlRaw().queryForMap(sql, value));	}	/**	 *  SQL을 직접 실행하여 1건의 정보를 가져온다.	 * @param sql	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected HoList queryForListSql(String sql, HoQueryParameterMap value)	{		logger.info(sql);		logger.info(value);		return new HoList((List)getSqlRaw().queryForObject(sql, value, newRowMapper()));	}	/**	 * SQL을 직접 실행하여 CUD를 실행한다.	 * @param sql	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected int updateSql(String sql, HoQueryParameterMap value)	{		return getSqlRaw().update(sql, value);	}	/**	 * SQL을 직접 실행하여 batch를 실행한다.	 * @param sql	 * @param value	 * @return	 * @throws NamingException	 * @throws SQLException	 * @throws HoException	 */	protected int [] batchSql(String sql, List value)	{		HoSqlBatchImpl batchImpl = new HoSqlBatchImpl(this.getDataSource(), sql, value);		batchImpl.update();		int [] result = batchImpl.getRowsAffected();		batchImpl.reset();		return result;	}	/**	 *  todo	 * @param rs	 * @param idx	 * @return	 */	public RowMapper newRowMapper() {		return new RowMapper() {			public Object mapRow(ResultSet rs, int row) {				return new Object();			}		}		 ;	}	/**	 * @return	 */	public Map<String, String> getCacheMap() {		if( this.cacheMap == null ) {			return new HashMap<String, String>();		} else {			return cacheMap;		}	}	/**	 * @param cacheMap	 */	public void setCacheMap(Map<String, String> cacheMap) {		this.cacheMap = cacheMap;	}	public Map<String, String> getDisplayFormat() {		return displayFormat;	}	public void setDisplayFormat(Map<String, String> displayFormat) {		this.displayFormat = displayFormat;	}	/**	 * sql을 실행한 쿼리를 debug한다.	 */	public String debug(String sql, Object [] params) {		StringBuffer sb = new StringBuffer();		StringBuffer result = new StringBuffer();		String [] str_comment = null;		if( sql.indexOf("/\\*") != -1 && sql.indexOf("\\*/") != -1) {			str_comment = sql.split("\\*/");			for( int i=0 ; i<str_comment.length ; i++ ) {				str_comment[i] = str_comment[i].substring(0, str_comment[i].indexOf("/\\*"));				sb.append(str_comment[i]);			}		} else {			sb.append(sql);		}		String [] str = sb.toString().split("\n");		sb = new StringBuffer();		for( int i=0 ; i<str.length ; i++ ) {			if( str[i].indexOf("--") != -1  ) {				str[i] = str[i].substring(0, str[i].indexOf("--"));			}			sb.append(str[i] +"\n");		}		StringTokenizer tok = new StringTokenizer(sb.toString(), "?");		String oneChunk = "";		int qMarkCount = 0;		try {			Object value;			while (tok.hasMoreTokens()) {				oneChunk = tok.nextToken();				result.append(oneChunk);				value = params[qMarkCount++];				if( value instanceof String || value instanceof Date ) {					result.append("'" + value +"' /* params */");				} else {					result.append(value + " /* params */");				}			}		} catch(Exception e) {			result.append(e.getMessage());		}		return result.toString();	}}