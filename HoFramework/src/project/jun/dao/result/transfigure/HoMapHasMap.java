package project.jun.dao.result.transfigure;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import java.util.TreeSet;import org.apache.ibatis.metadata.result.MetaData;import project.jun.dao.result.HoList;import project.jun.dao.result.HoMap;import project.jun.util.HoFormatter;import project.jun.util.HoUtil;/** * @author  sks */public class HoMapHasMap extends HashMap {	/**	 *	 */	private static final long serialVersionUID = -8415916320517648658L;	/**	 * @uml.property  name="metaData"	 */	private MetaData metaData = null;	/**	 * @uml.property  name="displayFormat"	 */	private Map      displayFormat          = null;	/**	 * HoMapList 생성자.	 */	public HoMapHasMap() {		super();	}	/**	 * HoMapList 생성자.	 */	public HoMapHasMap(HoList hoList, String key, String subKey) {		super();		for (int i = 0; i < hoList.size(); i++) {			this.setValue(hoList.getString(i, key), hoList.getString(i, subKey), hoList.toHoMap(i));		}	}	/**	 * ResultSetMetaData정보를 set	 * @return	 * @uml.property  name="metaData"	 */	public void setMetaData(MetaData metaData) {		this.metaData = metaData;	}	/**	 * 쿼리결과의 ResultSetMetaData정보를 return	 * @return	 * @uml.property  name="metaData"	 */	public MetaData getMetaData() {		return this.metaData;	}	/**	 * Data가 조회될때의 데이터 형태 yyyy/MM/dd or MM/dd/yyyy or MMM/dd/yyyy  or yyyy-MM-dd	 * @return	 * @uml.property  name="displayFormat"	 */	public Map getDisplayFormat() {		return this.displayFormat;	}	/**	 * Data가 조회될때의 데이터 형태 yyyy/MM/dd or MM/dd/yyyy or MMM/dd/yyyy  or yyyy-MM-dd	 * @return	 * @uml.property  name="displayFormat"	 */	public void setDisplayFormat(Map displayFormat) {		if( this.displayFormat == null ) {			this.displayFormat          = new HashMap();		}		this.displayFormat.putAll(displayFormat);	}	/**	 * Result를 통하여 "0"번째 결과값을 얻어가도록 처리한다.	 *	 * @param s	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param obj	 *            default객체	 */	public Object getValue(String key) {		return getValue(key, 0);	}	/**	 * Result를 통하여 i번째 결과값을 얻어가도록 처리한다.	 *	 * @param s	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param obj	 *            default객체	 * @return 결과반환값	 */	public Object getValue(String key, int i) {		ArrayList alist = (ArrayList) super.get(key);		if (alist == null)			return null;		try {			return alist.get(i);		} catch (IndexOutOfBoundsException ex) {			return null;		}	}	/**	 * Result를 통하여 i번째 결과값을 얻어가도록 처리한다.	 *	 * @param s	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param obj	 *            default객체	 * @return 결과반환값	 */	public HoMap getHoMap(String key, String subKey) {		Map map = (Map) super.get(key);		if (map == null)			return null;		try {			HoMap hoMap = (HoMap) map.get(subKey);			hoMap.setMetaData(this.getMetaData());			hoMap.setDisplayFormat(this.getDisplayFormat());			return hoMap;		} catch (IndexOutOfBoundsException ex) {			return null;		} catch (ClassCastException ex) {			return null;		}	}	/**	 * Result에서 key값에 해당하는HoList를 return한다.	 *	 * @param key	 * @return	 */	public HoList getHoList(String key, String subKey) {		List alist = new ArrayList();		if( this.getMetaData() !=null ) {			alist.add(this.getMetaData());		}		alist.addAll(getMap(key, subKey).entrySet());		HoList hoList = new HoList(alist);		hoList.setDisplayFormat(this.getDisplayFormat());		return hoList;	}	/**	 * Result에서 key값에 해당하는 HoList를 return한다.	 *	 * @param key	 * @return	 */	public HoList getHoList(Object key) {		return getHoList(key.toString());	}	/**	 * Result에서 key값에 해당하는 List를 return한다.	 *	 * @param key	 * @return	 */	public Map getMap(String key) {		Map map = (Map) super.get(key);		return map;	}	/**	 * Result에서 key값에 해당하는 List를 return한다.	 *	 * @param key	 * @return	 */	public Map getMap(Object key) {		return getMap(key.toString());	}	/**	 * Result에서 key값에 해당하는 List를 return한다.	 *	 * @param key	 * @return	 */	public Map getMap(String key, String subKey) {		Map map = (Map) super.get(key);		if( map != null ) {			return (Map) map.get(subKey);		}		return map;	}	/**	 * Result에서 key값에 해당하는 List를 return한다.	 *	 * @param key	 * @return	 */	public Map getMap(Object key, Object subKey) {		return getMap(key.toString(), subKey.toString());	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 *	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @return	 * @exception	 * @see	 */	public String getString(String key, String subKey, String column) {		return getString(key, subKey, column, "");	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 *	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @return	 * @exception	 * @see	 */	public String getString(Object key, String subKey, String column) {		return getString(key.toString(), subKey, column, "");	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0) -> return "0";	 *     2. getStringPart("0_1_5_10", 2) -> return "5";	 * @param fieldName	 * @param pos	 * @return	 */	public String getStringPart(String key, String subKey, String column, int pos ) {		return getStringPart(key, subKey, column, pos, "_", "_");	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0) -> return "0";	 *     2. getStringPart("0_1_5_10", 2) -> return "5";	 * @param fieldName	 * @param pos	 * @return	 */	public String getStringPart(String key, String subKey, String column, int pos, String defVal) {		return getStringPart(key, subKey, column, pos, "_", defVal);	}	/**	 * 여러 정보의 data를 delimeter구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0, "_") -> return "0";	 *     2. getStringPart("0_1_5_10", 2, "_") -> return "5";	 *     3. getStringPart("0_1_5_10", 4, "_") -> return "_"; (IndexOutOfBoundsException);	 * @param fieldName	 * @param pos	 * @param delimeter	 * @return	 */	public String getStringPart(String key, String subKey, String column, int pos, String delimeter, String defVal ) {		String [] parts = getString(key, subKey, column).split(delimeter);		if( parts.length > pos ) {			return parts[pos];		} else {			return defVal;		}	}	/**	 * "_"로 구분된 배열을 조회한다.	 * @param column	 * @return	 */	public String[] getStringParts(String key, String subKey, String column ) {		return getStringParts(key, subKey, column,  "_");	}	/**	 * delimeter 로 구분된 배열을 조회한다.	 * @param column	 * @param delimeter	 * @return	 */	public String[] getStringParts(String key, String subKey, String column, String delimeter ) {		return getString(key, subKey, column).split(delimeter);	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 String으로 가져온다.	 * </pre>	 *	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @param defaultValue	 *            만약 i번째 객체의 Map에서 유일한 식별자에 해당하는 값이 null일 경우 return할 값.	 * @return	 * @exception	 * @see	 */	public String getString(String key, String subKey, String column, String defaultValue) {		HoMap hoMap = getHoMap(key, subKey);		if( hoMap != null ) {			return hoMap.getString(column, defaultValue);		} else {			return defaultValue;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 html String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 *	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @return	 * @exception	 * @see	 */	public String getStringForHtml(String key, String subKey, String column) {		return getStringForHtml(key, subKey, column, "");	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 html String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 *	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @param defaultValue	 *            만약 i번째 객체의 Map에서 유일한 식별자에 해당하는 값이 null일 경우 return할 값.	 * @return	 * @exception	 * @see	 */	public String getStringForHtml(String key, String subKey, String column, String defaultValue) {		HoMap hoMap = getHoMap(key, subKey);		if( hoMap != null ) {			return hoMap.getStringForHtml(column);		} else {			return defaultValue;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 escaped String으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public String getStringForInput(String key, String subKey, String column) {		return getStringForInput(key, subKey, column, "");	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 escaped String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public String getStringForInput(String key, String subKey, String column, String defaultValue) {		HoMap hoMap = getHoMap(key, subKey);		if( hoMap != null ) {			return hoMap.getStringForInput(column);		} else {			return defaultValue;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 통화형태의 String으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public String getCurrencyFormat(String key, String subKey, String column) {		HoMap hoMap = getHoMap(key, subKey);		if( hoMap != null ) {			return hoMap.getCurrencyFormat(column);		} else {			return "0";		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 소수점형태의 String으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 */	public String getPointFormat(String key, String subKey, String column) {		HoMap hoMap = getHoMap(key, subKey);		if( hoMap != null ) {			return hoMap.getPointFormat(column);		} else {			return "0.00";		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 int으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public int getInt(String key, String subKey, String column) {		HoMap hoMap = getHoMap(key, subKey);		if( hoMap != null ) {			return hoMap.getInt(column);		} else {			return 0;		}	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0) -> return "0";	 *     2. getStringPart("0_1_5_10", 2) -> return "5";	 * @param fieldName	 * @param pos	 * @return	 */	public int getIntPart(String key, String subKey, String column, int pos ) {		return getIntPart(key, subKey, column, pos, "_", 0);	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0) -> return "0";	 *     2. getStringPart("0_1_5_10", 2) -> return "5";	 * @param fieldName	 * @param pos	 * @return	 */	public int getIntPart(String key, String subKey, String column, int pos, int defVal ) {		return getIntPart(key, subKey, column, pos, "_", defVal);	}	/**	 * 여러 정보의 data를 delimeter구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0, "_") -> return "0";	 *     2. getStringPart("0_1_5_10", 2, "_") -> return "5";	 *     3. getStringPart("0_1_5_10", 4, "_") -> return defVal; (IndexOutOfBoundsException);	 * @param fieldName	 * @param pos	 * @param delimeter	 * @return	 */	public int getIntPart(String key, String subKey, String column, int pos, String delimeter, int defVal ) {		String [] parts = getString(key, subKey, column).split(delimeter);		if( parts.length > pos ) {			try {				return Integer.parseInt(parts[pos]);			} catch(Exception e) {				return defVal;			}		} else {			return defVal;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 long으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public long getLong(String key, String subKey, String column) {		HoMap hoMap = getHoMap(key, subKey);		if( hoMap != null ) {			return hoMap.getLong(column);		} else {			return 0L;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 double으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public double getDouble(String key, String subKey, String column) {		HoMap hoMap = getHoMap(key, subKey);		if( hoMap != null ) {			return hoMap.getDouble(column);		} else {			return 0.0;		}	}	/**	 * Hashtable의 s값의 데이터를 put하도록 하며 실제 그안의 데이터를 순차값을 가진 ArrayList를 사용한다	 */	public void setValue(String key, String subKey, Object obj) {		Map map = (Map) super.get(key);		if (map == null) {			map = new HashMap();		}		map.put(subKey, obj);		put(key, map);	}	/**	 * s값에 의하여 저장된 데이터의 사이즈를 구하도록 한다.	 */	public int size(String key) {		Map map = (Map) super.get(key);		if (map == null)			return 0;		else			return map.size();	}	/**	 * s값에 의하여 저장된 데이터의 사이즈를 구하도록 한다.	 */	public int size(String key, String subKey) {		Map map = (Map) super.get(key);		if (map == null)			return 0;		else {			Map subMap = (Map) map.get(subKey);			if( subMap == null ) {				return 0;			} else {				return subMap.size();			}		}	}	public Set keySet(String key) {		Map map = (Map) super.get(key);		if( map == null ) {			return null;		} else {			return map.keySet();		}	}	/**	 * 맵의 ArrayList의 크기중 가장 큰값을 구한다.	 **/	public int maxSize() {		Set keySet = super.keySet();		Iterator iter = keySet.iterator();		int max = 0;		int min = 0;		while (iter.hasNext()) {			min = ((Map) super.get((String) iter.next())).size();			if (min > max) {				max = min;			}		}		return max;	}	/**	 * 전체 contents(ArrayList)의 크기구하기..	 **/	public int totalSize() {		Set keySet = super.keySet();		Iterator iter = keySet.iterator();		int size = 0;		while (iter.hasNext()) {			size += ((Map) super.get((String) iter.next())).size();		}		return size;	}	/**	 * keySet의 정보를 Iterator로 return한다.	 *	 * @return	 */	public Iterator keyIterator() {		return new TreeSet(super.keySet()).iterator();	}	/**	 * keySet의 정보를 Iterator로 return한다.	 *	 * @return	 */	public Iterator keyIterator(String key) {		Map map = (Map) super.get(key);		if(map == null) {			return null;		} else {			return new TreeSet(map.keySet()).iterator();		}	}	/**	 * 'columnValue1', 'columnValue2', 'columnValue3' ... 형태로 return	 *	 * @param idx	 * @return	 */	public String toJavaScriptArgString(String key, String subKey) {		StringBuffer sb = new StringBuffer();		for (int i = 0; getMetaData()!=null && i < getMetaData().getColumnCount(); i++) {			if (i != 0) {				sb.append(',');			}			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, subKey, getMetaData().getColumnName(i))));			sb.append('\'');		}		return sb.toString();	}	/**	 * { column_name1 : 'columnValue1', column_name2 : 'columnValue2',	 * column_name3 : 'columnValue3' ... }형태로 return	 *	 * @param idx	 * @return	 */	public String toJavaScriptObject(String key, String subKey) {		StringBuffer sb = new StringBuffer();		sb.append('{');		for (int i = 0; getMetaData()!=null && i < getMetaData().getColumnCount(); i++) {			if (i != 0) {				sb.append(',');			}			sb.append(getMetaData().getColumnName(i).toUpperCase());			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, subKey, getMetaData().getColumnName(i))));			sb.append('\'');		}		sb.append('}');		return sb.toString();	}	/**	 * { column_name1 : 'columnValue1', column_name2 : 'columnValue2',	 * column_name3 : 'columnValue3' ... }형태로 return	 *	 * @param idx	 * @return	 */	public String toJsonString(String key, String subKey) {		StringBuffer sb = new StringBuffer();		for (int i = 0; getMetaData()!=null && i < getMetaData().getColumnCount(); i++) {			if (i != 0) {				sb.append(',');			}			sb.append(getMetaData().getColumnName(i).toUpperCase());			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, subKey, getMetaData().getColumnName(i))));			sb.append('\'');		}		return sb.toString();	}	/**	 * Set에 해당하는 column을 가지고 { column_name1 : 'columnValue1', column_name2 :	 * 'columnValue2', column_name3 : 'columnValue3' ... }형태로 return	 *	 * @param idx	 * @return	 */	public String toJavaScriptObject(Set set, String key, String subKey) {		StringBuffer sb = new StringBuffer();		sb.append('{');		String setKey = null;		Iterator it = set.iterator();		for (int i = 0; it.hasNext(); i++) {			setKey = (String) it.next();			if (i != 0) {				sb.append(',');			}			sb.append(key);			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, subKey, setKey.toUpperCase())));			sb.append('\'');		}		sb.append('}');		return sb.toString();	}	/**	 * { column_name1 : 'columnValue1', column_name2 : 'columnValue2',	 * column_name3 : 'columnValue3' ... }형태로 return	 *	 * @param idx	 * @return	 */	public String toJsonString(Set set, String key, String subKey) {		StringBuffer sb = new StringBuffer();		String setKey = null;		Iterator it = set.iterator();		for (int i = 0; it.hasNext(); i++) {			setKey = (String) it.next();			if (i != 0) {				sb.append(',');			}			sb.append(key);			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, subKey, setKey.toUpperCase())));			sb.append('\'');		}		return sb.toString();	}	/**	 * Set에 해당하는 column을 가지고 { column_name1 : 'columnValue1', column_name2 :	 * 'columnValue2', column_name3 : 'columnValue3' ... }형태로 return	 *	 * @param idx	 * @return	 */	public String toJavaScriptObject(String[] set, String key, String subKey) {		StringBuffer sb = new StringBuffer();		sb.append('{');		for (int i = 0; i < set.length; i++) {			if (i != 0) {				sb.append(',');			}			sb.append(set[i]);			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, subKey, set[i].toUpperCase())));			sb.append('\'');		}		sb.append('}');		return sb.toString();	}	/**	 * Set에 해당하는 column을 가지고 { column_name1 : 'columnValue1', column_name2 :	 * 'columnValue2', column_name3 : 'columnValue3' ... }형태로 return	 *	 * @param idx	 * @return	 */	public String toJson(String[] set, String key, String subKey) {		StringBuffer sb = new StringBuffer();		for (int i = 0; i < set.length; i++) {			if (i != 0) {				sb.append(',');			}			sb.append(set[i]);			sb.append(':');			sb.append('\'');			sb.append(HoUtil.toJsonString(this.getString(key, subKey, set[i].toUpperCase())));			sb.append('\'');		}		return sb.toString();	}}