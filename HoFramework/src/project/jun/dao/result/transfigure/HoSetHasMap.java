package project.jun.dao.result.transfigure;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import java.util.TreeSet;import org.apache.ibatis.metadata.result.MetaData;import project.jun.dao.result.HoList;import project.jun.dao.result.HoMap;import project.jun.exception.HoException;/** * @author  sks */public class HoSetHasMap extends HashMap {	/**	 *	 */	private static final long serialVersionUID = -8415916320517648658L;	/**	 * @uml.property  name="metaData"	 */	private MetaData metaData = null;	/**	 * @uml.property  name="displayFormat"	 */	private Map      displayFormat          = new HashMap();	/**	 * HoMapList 생성자.	 */	public HoSetHasMap() {		super();	}	/**	 * HoMapList 생성자.	 * 	 * 쿼리 결과의 key컬럼에 해당하는 값을 기준으로 Array를 생성한다.	 * EX) COLUMN = {"값"}	 */	public HoSetHasMap(HoList hoList, String key) {		super();		if( hoList.getMetaData() != null ) {			this.setMetaData(hoList.getMetaData());		}		if( hoList.getDisplayFormat() != null ) {			this.setDisplayFormat(hoList.getDisplayFormat());		}		for (int i = 0; i < hoList.size(); i++) {			this.setValue(hoList.getString(i, key), hoList.toHoMap(i));		}	}	/**	 * HoMapList 생성자.	 * 쿼리 결과의 key컬럼+"."+subKey컬럼 에 해당하는 값을 기준으로 Array를 생성한다.	 * EX) TABLE.COLUMN = {"값"}	 */	public HoSetHasMap(HoList hoList, String key, String subKey) {		super();		if( hoList.getMetaData() != null ) {			this.setMetaData(hoList.getMetaData());		}		if( hoList.getDisplayFormat() != null ) {			this.setDisplayFormat(hoList.getDisplayFormat());		}		String valueKey = null;				for (int i = 0; i < hoList.size(); i++) {			// SUB_KEY의 값이 KEY의 값으로 시작할 경우			if( hoList.getString(i, subKey).startsWith(hoList.getString(i, key))) {				valueKey = hoList.getString(i, subKey);			} 			// 그룹코드와 코드가  시작 값이 다를 경우.			else {				valueKey = hoList.getString(i, key) + "."+ hoList.getString(i, subKey);			}			this.setValue(valueKey, hoList.toHoMap(i));		}	}		/**	 * HoMapList 생성자.	 * 쿼리 결과의 key컬럼+"."+subKey컬럼 에 해당하는 값을 기준으로 Array를 생성한다.	 * removeKey : key값을 Map에서 제거 할 지 여부 (Cache등록시 메모리 줄이게 UP_CD, CODE제거 )	 * EX) TABLE.COLUMN = {"값"}	 */	public HoSetHasMap(HoList hoList, String key, String subKey, boolean removeKey) {		super();		if( hoList.getMetaData() != null ) {			this.setMetaData(hoList.getMetaData());		}		if( hoList.getDisplayFormat() != null ) {			this.setDisplayFormat(hoList.getDisplayFormat());		}		String valueKey = null;				for (int i = 0; i < hoList.size(); i++) {			// SUB_KEY의 값이 KEY의 값으로 시작할 경우			if( hoList.getString(i, subKey).startsWith(hoList.getString(i, key))) {				valueKey = hoList.getString(i, subKey);			} 			// 그룹코드와 코드가  시작 값이 다를 경우.			else {				valueKey = hoList.getString(i, key) + "."+ hoList.getString(i, subKey);			} 						if( removeKey ) {				this.setValue(valueKey, hoList.toHoMap(i, new String[]{ key, subKey }));			} 			// 			else {				this.setValue(valueKey, hoList.toHoMap(i));			}		}	}		/**	 * 쿼리 결과의 key컬럼에 해당하는 값을 기준으로 Array를 생성한다.	 * EX) COLUMN = {"값"}	 */	public void put(HoList hoList, String key) throws HoException {		if( this.getMetaData() == null ) {			this.setMetaData(hoList.getMetaData());		}		if( this.getDisplayFormat() == null ) {			this.setDisplayFormat(hoList.getDisplayFormat());		}		for (int i = 0; i < hoList.size(); i++) {			this.setValue(hoList.getString(i, key), hoList.toHoMap(i));		}	}	/**	 * 쿼리 결과의 key컬럼+"."+subKey컬럼 에 해당하는 값을 기준으로 Array를 생성한다.	 * EX) TABLE.COLUMN = {"값"}	 */	public void put(HoList hoList, String key, String subKey) throws HoException {		if( this.getMetaData() == null ) {			this.setMetaData(hoList.getMetaData());		}		if( this.getDisplayFormat() == null ) {			this.setDisplayFormat(hoList.getDisplayFormat());		}		for (int i = 0; i < hoList.size(); i++) {			this.setValue(hoList.getString(i, key) + "."+ hoList.getString(i, subKey), hoList.toHoMap(i));		}	}	/**	 * ResultSetMetaData정보를 set	 * @return	 * @uml.property  name="metaData"	 */	public void setMetaData(MetaData metaData) {		this.metaData = metaData;	}	/**	 * 쿼리결과의 ResultSetMetaData정보를 return	 * @return	 * @uml.property  name="metaData"	 */	public MetaData getMetaData() {		return this.metaData;	}	/**	 * Data가 조회될때의 데이터 형태 yyyy/MM/dd or MM/dd/yyyy or MMM/dd/yyyy  or yyyy-MM-dd	 * @return	 * @uml.property  name="displayFormat"	 */	public Map getDisplayFormat() {		return this.displayFormat;	}	/**	 * Data가 조회될때의 데이터 형태 yyyy/MM/dd or MM/dd/yyyy or MMM/dd/yyyy  or yyyy-MM-dd	 * @return	 * @uml.property  name="displayFormat"	 */	public void setDisplayFormat(Map displayFormat) {		if( this.displayFormat == null ) {			this.displayFormat          = new HashMap();		}		this.displayFormat.putAll(displayFormat);	}	/**	 * Result를 통하여 "0"번째 결과값을 얻어가도록 처리한다.	 *	 * @param s	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param obj	 *            default객체	 */	public Object getValue(String key) {		return super.get(key);	}	/**	 * Result를 통하여 i번째 결과값을 얻어가도록 처리한다.	 *	 * @param s	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param obj	 *            default객체	 * @return 결과반환값	 */	public HoMap getHoMap(String key) {		return (HoMap) super.get(key);	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 *	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @return	 * @exception	 * @see	 */	public String getString(String key,  String column) {		return getString(key, column, "");	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 *	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @return	 * @exception	 * @see	 */	public String getString(Object key, String column) {		return getString(key.toString(), column, "");	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 String으로 가져온다.	 * </pre>	 *	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @param defaultValue	 *            만약 i번째 객체의 Map에서 유일한 식별자에 해당하는 값이 null일 경우 return할 값.	 * @return	 * @exception	 * @see	 */	public String getString(String key, String column, String defaultValue) {		HoMap hoMap = getHoMap(key);		if( hoMap != null ) {			return hoMap.getString(column, defaultValue);		} else {			return defaultValue;		}	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0) -> return "0";	 *     2. getStringPart("0_1_5_10", 2) -> return "5";	 * @param fieldName	 * @param pos	 * @return	 */	public String getStringPart(String key, String column, int pos ) {		return getStringPart(key, column, pos, "_", "_");	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0) -> return "0";	 *     2. getStringPart("0_1_5_10", 2) -> return "5";	 * @param fieldName	 * @param pos	 * @return	 */	public String getStringPart(String key, String column, int pos, String defVal) {		return getStringPart(key, column, pos, "_", defVal);	}	/**	 * 여러 정보의 data를 delimeter구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0, "_") -> return "0";	 *     2. getStringPart("0_1_5_10", 2, "_") -> return "5";	 *     3. getStringPart("0_1_5_10", 4, "_") -> return "_"; (IndexOutOfBoundsException);	 * @param fieldName	 * @param pos	 * @param delimeter	 * @return	 */	public String getStringPart(String key, String column, int pos, String delimeter, String defVal ) {		String [] parts = getString(key, column).split(delimeter);		if( parts.length > pos ) {			return parts[pos];		} else {			return defVal;		}	}	/**	 * "_"로 구분된 배열을 조회한다.	 * @param column	 * @return	 */	public String[] getStringParts(String key, String column ) {		return getStringParts(key, column,  "_");	}	/**	 * delimeter 로 구분된 배열을 조회한다.	 * @param column	 * @param delimeter	 * @return	 */	public String[] getStringParts(String key, String column, String delimeter ) {		return getString(key, column).split(delimeter);	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 html String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 *	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @return	 * @exception	 * @see	 */	public String getStringForHtml(String key, String column) {		return getStringForHtml(key, column, "");	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 html String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 *	 * @param key	 *            value값에 대한 유일한 식별자	 * @param i	 *            객체의 위치	 * @param column	 *            i번째 객체의 Map에서 유일한 식별자.	 * @param defaultValue	 *            만약 i번째 객체의 Map에서 유일한 식별자에 해당하는 값이 null일 경우 return할 값.	 * @return	 * @exception	 * @see	 */	public String getStringForHtml(String key,String column, String defaultValue) {		HoMap hoMap = getHoMap(key);		if( hoMap != null ) {			return hoMap.getStringForHtml(column);		} else {			return defaultValue;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 escaped String으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public String getStringForInput(String key, String column) {		return getStringForInput(key, column, "");	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 escaped String으로 가져온다.	 * 	만약 결과값이 null일 경우 ""를 return한다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public String getStringForInput(String key, String column, String defaultValue) {		HoMap hoMap = getHoMap(key);		if( hoMap != null ) {			return hoMap.getStringForInput(column);		} else {			return defaultValue;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 통화형태의 String으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public String getCurrencyFormat(String key, String column) {		HoMap hoMap = getHoMap(key);		if( hoMap != null ) {			return hoMap.getCurrencyFormat(column);		} else {			return "0";		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 소수점형태의 String으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 */	public String getPointFormat(String key, String column) {		HoMap hoMap = getHoMap(key);		if( hoMap != null ) {			return hoMap.getPointFormat(column);		} else {			return "0.00";		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 int으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public int getInt(String key, String column) {		HoMap hoMap = getHoMap(key);		if( hoMap != null ) {			return hoMap.getInt(column);		} else {			return 0;		}	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0) -> return "0";	 *     2. getStringPart("0_1_5_10", 2) -> return "5";	 * @param fieldName	 * @param pos	 * @return	 */	public int getIntPart(String key, String column, int pos ) {		return getIntPart(key, column, pos, "_", 0);	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0) -> return "0";	 *     2. getStringPart("0_1_5_10", 2) -> return "5";	 * @param fieldName	 * @param pos	 * @return	 */	public int getIntPart(String key, String column, int pos, int defVal ) {		return getIntPart(key, column, pos, "_", defVal);	}	/**	 * 여러 정보의 data를 delimeter구분자로 구분되어있을 경우 pos에 해당하는 값을 return	 * ex) 1. getStringPart("0_1_5_10", 0, "_") -> return "0";	 *     2. getStringPart("0_1_5_10", 2, "_") -> return "5";	 *     3. getStringPart("0_1_5_10", 4, "_") -> return defVal; (IndexOutOfBoundsException);	 * @param fieldName	 * @param pos	 * @param delimeter	 * @return	 */	public int getIntPart(String key, String column, int pos, String delimeter, int defVal ) {		String [] parts = getString(key, column).split(delimeter);		if( parts.length > pos ) {			try {				return Integer.parseInt(parts[pos]);			} catch(Exception e) {				return defVal;			}		} else {			return defVal;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 long으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public long getLong(String key, String column) {		HoMap hoMap = getHoMap(key);		if( hoMap != null ) {			return hoMap.getLong(column);		} else {			return 0L;		}	}	/**	 * <pre>	 * 결과값이 Map형태일 경우 i번째 객체의 column에 해당한는 결과값을 double으로 가져온다.	 * </pre>	 *	 * @param key	 * @param i	 * @param column	 * @return	 * @exception	 * @see	 */	public double getDouble(String key, String column) {		HoMap hoMap = getHoMap(key);		if( hoMap != null ) {			return hoMap.getDouble(column);		} else {			return 0.0;		}	}	/**	 * Hashtable의 s값의 데이터를 put하도록 하며 실제 그안의 데이터를 순차값을 가진 ArrayList를 사용한다	 */	public void setValue(String key, Object obj){		put(key, obj);	}	/**	 * keySet의 정보를 Iterator로 return한다.	 *	 * @return	 */	public Iterator keyIterator() {		return new TreeSet(super.keySet()).iterator();	}}