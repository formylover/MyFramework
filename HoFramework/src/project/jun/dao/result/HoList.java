package project.jun.dao.result;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import java.util.TreeSet;import org.apache.ibatis.metadata.result.MetaData;import project.jun.dao.result.transfigure.HoMapHasList;import project.jun.dao.result.transfigure.HoSetHasMap;import project.jun.exception.HoException;import project.jun.util.HoFormatter;import project.jun.util.HoUtil;/** * @author sks */public class HoList extends HoResult {	private  List<Object> list = null;	public HoList() {		this.list = new ArrayList<Object>();	}	/**	 * iBatis 실행후 1건의 결과 값이 있을 경우 return한 Objec가 List형태이고, 첫번째 정보가	 * ResultSetMetaData정보일 경우 1번째 MetaData정보는 MetaData에 넣고, 2번째 부터의 쿼리 결과값은	 * List객체에 넣는다.	 *	 * @param obj	 */	public HoList(List<Object> list) {		if (list != null && list.size() > 0 && list.get(0) instanceof MetaData) {			super.setMetaData((MetaData) list.get(0));			list.remove(0);		}		this.list = list;	}	/**	 * iBatis 실행후 1건의 결과 값이 있을 경우 return한 Objec가 List형태이고, 첫번째 정보가	 * ResultSetMetaData정보일 경우 1번째 MetaData정보는 MetaData에 넣고, 2번째 부터의 쿼리 결과값은	 * List객체에 넣는다.	 *	 * @param obj	 * @uml.property name="list"	 */	public void setList(List<Object> list) {		if (list != null && list.size() > 0 && list.get(0) instanceof MetaData) {			super.setMetaData((MetaData) list.get(0));			list.remove(0);		}		this.list = list;	}	/**	 * 실제 결과 List를 조회한다.	 *	 * @return	 * @uml.property name="list"	 */	public List<Object> getList() {		return this.list;	}	public List<Object> getList(String column) {		List<Object> _list = new ArrayList<Object>(this.list.size());		for( int i=0 ; i<this.list.size() ; i++ ) {			_list.add(this.get(i, column));		}		return _list;	}	/**	 * 실제 결과중 idx에 해당하는 결과를 구한다.	 *	 * @param idx	 * @return	 */	public Map<String, Object> get(int idx) {		if (idx < this.list.size()) {			if( this.list.get(idx) instanceof HoMap ) {				return ((HoMap) this.list.get(idx)).getMap();			} else {				return (Map<String, Object>) this.list.get(idx);			}		} else {			return null;		}	}	/**	 * 실제 결과중 idx에 해당하는 결과를 구한다.	 *	 * @param idx	 * @return	 */	public Map<String, Object> getRecord(int idx) {		if (idx < this.list.size()) {			if( this.list.get(idx) instanceof HoMap ) {				return ((HoMap) this.list.get(idx)).getMap();			} else {				return (Map<String, Object>) this.list.get(idx);			}		} else {			return null;		}	}	/**	 * 실제 결과중 idx에 해당하는 결과를 구한다.	 *	 * @param idx	 * @return	 */	public HoMap toHoMap(int idx) {		if (idx < this.list.size()) {			List<Object> hoMapList = new ArrayList<Object>();			hoMapList.add(this.getMetaData());			hoMapList.add(this.list.get(idx));			return new HoMap(hoMapList);		}		else			return null;	}	/**	 * 실제 결과중 idx에 해당하는 결과를 구한다.	 *	 * @param idx	 * @return	 */	public HoMap toHoMap(int idx, String [] keys) {		if (idx < this.list.size()) {			List<Object> hoMapList = new ArrayList<Object>();			hoMapList.add(this.getMetaData());						Map map = (Map) this.list.get(idx);			for( String key : keys ) {				map.remove(key);			}			hoMapList.add(map);			return new HoMap(hoMapList);		}		else			return null;	}	/**	 * 결과값의 크기를 구한다.	 *	 * @return	 */	public int size() {		if( this.list == null) {			return 0;		} else {			return this.list.size();		}	}	/**	 * <pre>	 * WizMapList의 row의 MetaData Key Set을 조회한다.	 * </pre>	 *	 * @param list	 * @return	 * @exception	 * @see	 */	public Set getKetSet() {		Map map = null;		Set keySet = null;		if (size() > 0) {			// ResultSetMetaData정보를 조회한다.			map = getRecord(0);			// Record의 key를 조회한다.			keySet = new TreeSet(map.keySet());		}		return keySet;	}	/**	 * 쿼리결과의 컬럼필드를 Iterator로 return한다. 단, 쿼리 결과가 있어야 사용가능함..	 *	 * @return	 */	public Iterator keyIterator() {		Map map = null;		Set keySet = null;		if (size() > 0) {			// ResultSetMetaData정보를 조회한다.			map = getRecord(0);			// Record의 key를 조회한다.			keySet = new TreeSet(map.keySet());		}		if (keySet != null) {			return keySet.iterator();		}		else {			return null;		}	}	/**	 * 쿼리 결과값이 없는지 확인	 *	 * @return boolean	 */	public boolean isEmpty() {		if (this.list == null) {			return true;		}		return (this.size() == 0);	}	/**	 * <pre>	 * WizMapList형태의 결과값을 WisDataList의 형태로 변환한다.	 * key값이 하나가 아니고, 조건에 의해 변해야 할 경우에는	 * 각각의 DELEGATE에서 상황에 맞게 수정해서 사용한다.	 * </pre>	 *	 * @param row	 * @param column	 * @return	 * @exception	 * @see	 */	public HoMapHasList toHoMapHasList(String key) {		/*		 * HoMapHasList dataList = new HoMapHasList( );		 *		 * dataList.setMetaData(this.getMetaData());		 * dataList.setDisplayFormat(this.getDisplayFormat());		 *		 * for( int i=0 ; i<list.size() ; i++ ) { dataList.setValue(getString(i,		 * key), toHoMap(i)); }		 */		return new HoMapHasList(this, key);	}	public HoSetHasMap toHoSetHasMap(String key) throws HoException {		return new HoSetHasMap(this, key);	}		/**	 * <pre>	 * 해당 index의 column명에 해당하는 원래의 객체정보를 가져온다.	 * </pre>	 *	 * @param row	 * @param column	 * @return	 * @exception	 * @see	 */	public Object get(int row, String column) {		Object map = this.list.get(row);		if (map instanceof HoMap) {			return ((HoMap) map).get(column.toUpperCase());		}		else {			HoMap hoMap = toHoMap(row);			if (hoMap == null) {				return null;			}			else {				return hoMap.get(column.toUpperCase());			}		}	}	/**	 * <pre>	 * record를 추가한다.	 * </pre>	 *	 * @param row	 * @param column	 * @return	 * @exception	 * @see	 */	public boolean add(Map record) {		return this.list.add(record);	}	/**	 * <pre>	 * 해당 index의 column명에 객체를 삽입한다.	 * </pre>	 *	 * @param row	 * @param column	 * @return	 * @exception	 * @see	 */	public Object put(int row, String column, Object value) {		Map map = (Map) this.list.get(row);		return map.put(column, value);	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 String 형태로 return 1. 결과 값이 Data형태일 경우에는	 * yyyy-MM-dd형태로 return 2. 결과 값이 null이거나, Exception발생시에는 ""를 return	 *	 * @param column	 * @return	 */	public String getString(int row, String column) {		return getString(row, column, "");	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 String 형태로 return 1. 결과 값이 Data형태일 경우에는	 * yyyy-MM-dd형태로 return 2. 결과 값이 null이거나, Exception발생시에는 defaultValue를	 * return	 *	 * @param column	 * @param defaultValue	 * @return	 */	public String getString(int row, String column, String defaultValue) {		return getString(column, get(row, column), defaultValue);	}	/**	 * "_"로 구분된 배열을 조회한다.	 *	 * @param column	 * @return	 */	public String[] getStringParts(int row, String column) {		return getStringParts(row, column, "_");	}	/**	 * delimeter 로 구분된 배열을 조회한다.	 *	 * @param column	 * @param delimeter	 * @return	 */	public String[] getStringParts(int row, String column, String delimeter) {		return getString(row, column).split(delimeter);	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return ex) 1.	 * getStringPart("0_1_5_10", 0) -> return "0"; 2. getStringPart("0_1_5_10",	 * 2) -> return "5";	 *	 * @param column	 * @param pos	 * @return	 */	public String getStringPart(int row, String column, int pos) {		return getStringPart(row, column, pos, "_", "_");	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return ex) 1.	 * getStringPart("0_1_5_10", 0) -> return "0"; 2. getStringPart("0_1_5_10",	 * 2) -> return "5";	 *	 * @param column	 * @param pos	 * @return	 */	public String getStringPart(int row, String column, int pos, String defVal) {		return getStringPart(row, column, pos, "_", defVal);	}	/**	 * 여러 정보의 data를 delimeter구분자로 구분되어있을 경우 pos에 해당하는 값을 return ex) 1.	 * getStringPart("0_1_5_10", 0, "_") -> return "0"; 2.	 * getStringPart("0_1_5_10", 2, "_") -> return "5"; 3.	 * getStringPart("0_1_5_10", 4, "_") -> return "_";	 * (IndexOutOfBoundsException);	 *	 * @param column	 * @param pos	 * @param delimeter	 * @return	 */	public String getStringPart(int row, String column, int pos, String delimeter, String defVal) {		String[] parts = getString(row, column).split(delimeter);		if (parts.length > pos) {			return parts[pos];		}		else {			return defVal;		}	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 int 형태로 return 1. 결과 값이 null이거나, Exception발생시에는	 * 0을 return	 *	 * @param row	 * @param column	 * @return	 */	public int getInt(int row, String column) {		return getInt(row, column, 0);	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 int 형태로 return 1. 결과 값이 null이거나, Exception발생시에는	 * detaultValue를 return	 *	 * @param row	 * @param column	 * @param detaultValue	 * @return	 */	public int getInt(int row, String column, int detaultValue) {		return getInt(column, get(row, column), detaultValue);	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return ex) 1.	 * getStringPart("0_1_5_10", 0) -> return "0"; 2. getStringPart("0_1_5_10",	 * 2) -> return "5";	 *	 * @param column	 * @param pos	 * @return	 */	public int getIntPart(int row, String column, int pos) {		return getIntPart(row, column, pos, "_", 0);	}	/**	 * 여러 정보의 data를 "_"구분자로 구분되어있을 경우 pos에 해당하는 값을 return ex) 1.	 * getStringPart("0_1_5_10", 0) -> return "0"; 2. getStringPart("0_1_5_10",	 * 2) -> return "5";	 *	 * @param column	 * @param pos	 * @return	 */	public int getIntPart(int row, String column, int pos, int defVal) {		return getIntPart(row, column, pos, "_", defVal);	}	/**	 * 여러 정보의 data를 delimeter구분자로 구분되어있을 경우 pos에 해당하는 값을 return ex) 1.	 * getStringPart("0_1_5_10", 0, "_") -> return "0"; 2.	 * getStringPart("0_1_5_10", 2, "_") -> return "5"; 3.	 * getStringPart("0_1_5_10", 4, "_") -> return defVal;	 * (IndexOutOfBoundsException);	 *	 * @param column	 * @param pos	 * @param delimeter	 * @return	 */	public int getIntPart(int row, String column, int pos, String delimeter, int defVal) {		String[] parts = getString(row, column).split(delimeter);		if (parts.length > pos) {			try {				return Integer.parseInt(parts[pos]);			} catch (Exception e) {				return defVal;			}		}		else {			return defVal;		}	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 long 형태로 return 1. 결과 값이 null이거나,	 * Exception발생시에는 0L을 return	 *	 * @param row	 * @param column	 * @return	 */	public long getLong(int row, String column) {		return getLong(row, column, 0L);	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 long 형태로 return 1. 결과 값이 null이거나,	 * Exception발생시에는 0L을 return	 *	 * @param row	 * @param column	 * @param detaultValue	 * @return	 */	public long getLong(int row, String column, long detaultValue) {		return getLong(column, get(row, column), detaultValue);	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 double 형태로 return 1. 결과 값이 null이거나,	 * Exception발생시에는 0을 return	 *	 * @param row	 * @param column	 * @return	 */	public double getDouble(int row, String column) {		return getDouble(row, column, 0.0);	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 double 형태로 return 1. 결과 값이 null이거나,	 * Exception발생시에는 0을 return	 *	 * @param row	 * @param column	 * @param detaultValue	 * @return	 */	public double getDouble(int row, String column, double detaultValue) {		return getDouble(column, get(row, column), detaultValue);	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 escape형태로 return (&, >, <, ', \, \\x28, \\x29,	 * \r\n, \n, ' ', \t)문자만 변경	 *	 * @param row	 * @param column	 * @return	 */	public String getStringForHtml(int row, String column) {		return HoUtil.escapeForHtml(getString(row, column));	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 escape형태로 return (&, >, <, ', \)문자만 변경	 *	 * @param row	 * @param column	 * @return	 */	public String getStringForInput(int row, String column) {		return HoUtil.escapeForInput(getString(row, column));	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 ###,###,###,###,###,###,###형태로 return	 *	 * @param row	 * @param column	 * @return	 */	public String getCurrencyFormat(int row, String column) {		return HoFormatter.toCurrencyFormat(getString(row, column),				displayFormat.get("CURRENCY").toString());	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 format형태로 return	 *	 * @param row	 * @param column	 * @return	 */	public String getCurrencyFormat(int row, String column, String format) {		return HoFormatter.toNumbericFormat(get(row, column), format);	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 ###,###,###,###,###,###,###.000형태로 return	 *	 * @param row	 * @param column	 * @return	 */	public String getPointFormat(int row, String column) {		return HoFormatter.toPointFormat(get(row, column), super.getPointFormat(column));	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 ###,###,###,###,###,###,###.000형태로 return	 *	 * @param row	 * @param column	 * @return	 */	public String getPointFormat(int row, String column, String format) {		return HoFormatter.toPointFormat(getString(row, column), format);	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 "#,##0.00"형태로 return 1. 결과 값이 null이거나,	 * Exception발생시에는 0를 return	 *	 * @param row	 * @param column	 * @return	 */	public String getNumberFormat(int row, String column) {		return HoFormatter.toNumberFormat(get(row, column), displayFormat.get("NUMBER").toString());	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 format형태로 return 1. 결과 값이 null이거나,	 * Exception발생시에는 0를 return	 *	 * @param row	 * @param column	 * @return	 */	public String getNumberFormat(int row, String column, String format) {		return getNumberFormat(row, column, "0", format);	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 format형태로 return 1. 결과 값이 null이거나,	 * Exception발생시에는 defaultValue를 return	 *	 * @param row	 * @param column	 * @param format	 * @return	 */	public String getNumberFormat(int row, String column, String defaultValue, String format) {		return getNumberFormat(column, get(row, column), defaultValue, format);	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 [년월일]로 구분한 형태로 return	 *	 * @param column	 * @return	 */	public String getDateFormat(int row, String column) {		return HoFormatter.toDateFormat(get(row, column), displayFormat);	}	/**	 * 쿼리 결과중 column컬럼에 해당하는 결과를 [년월일시분초]로 구분한 형태로 return	 *	 * @param column	 * @return	 */	public String getDateTimeFormat(int row, String column) {		return HoFormatter.toDateTimeFormat(get(row, column), displayFormat);	}	/**	 * 쿼리 결과 Map을 String으로 return한다.	 */	public String toString() {		if (this.list == null) {			return null;		}		else {			return this.list.toString();		}	}	/**	 * 쿼리 결과 Map을 String으로 return한다.	 */	public String toString(int row) {		if (this.list == null) {			return null;		}		else {			return this.toHoMap(row).toString();		}	}	/**	 * <pre>	 * WizMapList의 각각의 row에 해당하는 정보를 element로 만들어 준다.	 * </pre>	 *	 * @param list	 * @param rowCnt	 * @return	 * @exception	 * @see	 */	public String toXMLList(String id) {		StringBuffer sbRow = new StringBuffer(1024);		// list의 각 row별 key값을 다시 초기화 한다.		sbRow.append("<dataset id=\"" + id + "\">\n");		for (int row = 0; row < list.size(); row++) {			sbRow.append("	<record>\n");			sbRow.append("		<rownum>");			sbRow.append("<![CDATA[" + (row + 1) + "]]>");			sbRow.append("</rownum>\n");			for (int i = 0; i < getMetaData().getColumnCount(); i++) {				sbRow.append("		<" + getMetaData().getColumnName(i).toUpperCase() + ">");				sbRow.append("<![CDATA[" + this.getString(row, getMetaData().getColumnName(i)) + "]]>");				sbRow.append("</" + getMetaData().getColumnName(i).toUpperCase() + ">\n");			}			sbRow.append("	</record>\n");		}		sbRow.append("</dataset>");		return sbRow.toString();	}	/**	 * <pre>	 * WizMapList의 각각의 row에 해당하는 정보를 element로 만들어 준다.	 * </pre>	 *	 * @param list	 * @param rowCnt	 * @return	 * @exception	 * @see	 */	public String toXML(int row) {		StringBuffer sbRow = new StringBuffer(1024);		// list의 각 row별 key값을 다시 초기화 한다.		sbRow.append("	<record>\n");		for (int i = 0; i < getMetaData().getColumnCount(); i++) {			sbRow.append("		<" + getMetaData().getColumnName(i).toUpperCase() + ">");			sbRow.append("<![CDATA[" + this.getString(row, getMetaData().getColumnName(i)) + "]]>");			sbRow.append("</" + getMetaData().getColumnName(i).toUpperCase() + ">\n");		}		sbRow.append("	</record>\n");		return sbRow.toString();	}	/**	 * <pre>	 * javascript형태	 * </pre>	 */	public String toJavascriptDataArray() {		return toJavascriptDataArray(0);	}	/**	 * <pre>	 * javascript형태	 * </pre>	 */	public String toJavascriptDataArray(int fromIdx) {		StringBuffer sbRow = new StringBuffer(1024);		sbRow.append('[');		for (int row = fromIdx; row < list.size(); row++) {			if (row != fromIdx) {				sbRow.append(',');			}			sbRow.append('[');			for (int i = 0; i < getMetaData().getColumnCount(); i++) {				if (i != 0) {					sbRow.append(',');				}				sbRow.append('\"' + HoUtil.toJsonString(getString(row, getMetaData().getColumnName(i))) + '\"');			}			sbRow.append(']').append('\r').append('\n');		}		sbRow.append(']').append('\r').append('\n');		return sbRow.toString();	}	public String toJavascriptArray(int fromIdx) {		StringBuffer sbRow = new StringBuffer(1024);		sbRow.append('[');		for (int row = fromIdx; row < list.size(); row++) {			if (row != fromIdx) {				sbRow.append(',');			}			sbRow.append('{');			for (int i = 0; i < getMetaData().getColumnCount(); i++) {				if (i != 0) {					sbRow.append(',');				}				sbRow.append('\"' + getMetaData().getColumnName(i) + '\"' + ':' + '\"' + HoUtil.toJsonString(getString(row, getMetaData().getColumnName(i))) + '\"');			}			sbRow.append('}').append('\r').append('\n');		}		sbRow.append(']').append('\r').append('\n');		return sbRow.toString();	}	/**	 * 'columnValue1', 'columnValue2', 'columnValue3' ... 형태로 return	 *	 * @param idx	 * @return	 */	public String toJavaScriptArgString(int row) {		StringBuffer sb = new StringBuffer();		for (int i = 0; i < getMetaData().getColumnCount(); i++) {			if (i != 0) {				sb.append(',');			}			sb.append('\"');			sb.append(HoUtil.toJsonString(this.getString(row, getMetaData().getColumnName(i))));			sb.append('\"');		}		return sb.toString();	}	/**	 * columnName1 : 'columnValue1', columnName2 : 'columnValue2', columnName3 :	 * 'columnValue3' ... 형태로 return	 *	 * @param idx	 * @return	 */	public String toJsonCamel(int row) {		String[] arrSet = new String[getMetaData().getColumnCount()];		for (int i = 0; i < getMetaData().getColumnCount(); i++) {			arrSet[i] = getMetaData().getColumnName(i);		}		return toJsonCamel(row, arrSet);	}	/**	 * columnName1 : 'columnValue1', columnName2 : 'columnValue2', columnName3 :	 * 'columnValue3' ... 형태로 return	 *	 * @param idx	 * @return	 */	public String toJsonCamel(int row, Set set) {		String[] arrSet = new String[set.size()];		Iterator it = set.iterator();		for (int i = 0; it.hasNext(); i++) {			arrSet[i] = (String) it.next();		}		return toJsonCamel(row, arrSet);	}	/**	 * columnName1 : 'columnValue1', columnName2 : 'columnValue2', columnName3 :	 * 'columnValue3' ... 형태로 return	 *	 * @param idx	 * @return	 */	public String toJsonCamel(int row, String[] set) {		StringBuffer sb = new StringBuffer();		for (int i = 0; i < set.length; i++) {			if (i != 0) {				sb.append(',');			}			sb.append(HoUtil.toCamel(set[i]));			sb.append(':');			sb.append('\"');			sb.append(HoUtil.toJsonString(this.getString(row, set[i].toUpperCase())));			sb.append('\"');		}		return sb.toString();	}	/**	 * column_name1 : 'columnValue1', column_name2 : 'columnValue2',	 * column_name3 : 'columnValue3' ... 형태로 return	 *	 * @param idx	 * @return	 */	public String toJson(int row) {		String[] arrSet = new String[getMetaData().getColumnCount()];		for (int i = 0; i < getMetaData().getColumnCount(); i++) {			arrSet[i] = getMetaData().getColumnName(i);		}		return toJson(row, arrSet);	}	/**	 * column_name1 : 'columnValue1', column_name2 : 'columnValue2',	 * column_name3 : 'columnValue3' ... 형태로 return	 *	 * @param idx	 * @return	 */	public String toJson(int row, Set set) {		String[] arrSet = new String[set.size()];		Iterator it = set.iterator();		for (int i = 0; it.hasNext(); i++) {			arrSet[i] = (String) it.next();		}		return toJson(row, arrSet);	}	/**	 * column_name1 : 'columnValue1', column_name2 : 'columnValue2',	 * column_name3 : 'columnValue3' ... 형태로 return	 *	 * @param idx	 * @return	 */	public String toJson(int row, String[] set) {		StringBuffer sb = new StringBuffer();		for (int i = 0; i < set.length; i++) {			if (i != 0) {				sb.append(',');			}			sb.append(set[i].toUpperCase());			sb.append(':');			sb.append('\"');			sb.append(HoUtil.toJsonString(this.getString(row, set[i].toUpperCase())));			sb.append('\"');		}		return sb.toString();	}	/**	 * column_name1 : 'columnValue1', column_name2 : 'columnValue2',	 * column_name3 : 'columnValue3' ... 형태로 return	 *	 * @param idx	 * @return	 */	public String toJson(int row, String[][] set) {		StringBuffer sb = new StringBuffer();		for (int i = 0; i < set.length; i++) {			if (i != 0) {				sb.append(',');			}			sb.append(set[i][0].toUpperCase());			sb.append(':');			sb.append('\"');			sb.append(HoUtil.toJsonString(this.getString(row, set[i][1].toUpperCase())));			sb.append('\"');		}		return sb.toString();	}	/**	 * { column_name1 : 'columnValue1', column_name2 : 'columnValue2',	 * column_name3 : 'columnValue3' ... }형태로 return	 *	 * @param idx	 * @return	 */	public String toJavaScriptObject(int row) {		String[] arrSet = new String[getMetaData().getColumnCount()];		for (int i = 0; i < getMetaData().getColumnCount(); i++) {			arrSet[i] = getMetaData().getColumnName(i);		}		return toJavaScriptObject(row, arrSet);	}	/**	 * Set에 해당하는 column을 가지고 { column_name1 : 'columnValue1', column_name2 :	 * 'columnValue2', column_name3 : 'columnValue3' ... }형태로 return	 *	 * @param idx	 * @return	 */	public String toJavaScriptObject(int row, Set set) {		String[] arrSet = new String[set.size()];		Iterator it = set.iterator();		for (int i = 0; it.hasNext(); i++) {			arrSet[i] = (String) it.next();		}		return toJavaScriptObject(row, arrSet);	}	/**	 * Set에 해당하는 column을 가지고 { column_name1 : 'columnValue1', column_name2 :	 * 'columnValue2', column_name3 : 'columnValue3' ... }형태로 return	 *	 * @param idx	 * @return	 */	public String toJavaScriptObject(int row, String[] set) {		StringBuffer sb = new StringBuffer();		sb.append('{');		for (int i = 0; i < set.length; i++) {			if (i != 0) {				sb.append(',');			}			sb.append(set[i].toUpperCase());			sb.append(':');			sb.append('\"');			sb.append(HoUtil.toJsonString(this.getString(row, set[i].toUpperCase())));			sb.append('\"');		}		sb.append('}');		return sb.toString();	}}